<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MindAR + A-Frame — Touch rotate</title>

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>

    <!-- MindAR (image aframe integration) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image.prod.css" />
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image-aframe.prod.js"></script>

    <style>
      html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
      .mindar-container { width:100% !important; height:100% !important; position:fixed; inset:0; }
      video { object-fit: cover !important; }
      /* pequenas instruções na tela */
      #hint {
        position: absolute;
        left: 12px;
        bottom: 18px;
        background: rgba(0,0,0,0.45);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        font-family: sans-serif;
        font-size: 14px;
        z-index: 9999;
      }
    </style>

    <script>
      /* Componente para rotacionar o modelo com toque/mouse */
      AFRAME.registerComponent('touch-rotate', {
        schema: {
          invertY: { type: 'boolean', default: false }, // opcional
          sensitivity: { type: 'number', default: 0.4 } // quanto arrastar gira mais rápido
        },
        init: function () {
          this.dragging = false;
          this.startX = 0;
          this.startY = 0;
          this.startRot = new THREE.Euler();
          this.el.object3D.rotation.order = 'YXZ'; // garantir ordem
          // bind handlers
          this._onPointerDown = this.onPointerDown.bind(this);
          this._onPointerMove = this.onPointerMove.bind(this);
          this._onPointerUp = this.onPointerUp.bind(this);

          // add event listeners
          window.addEventListener('pointerdown', this._onPointerDown);
          window.addEventListener('pointermove', this._onPointerMove);
          window.addEventListener('pointerup', this._onPointerUp);
          window.addEventListener('pointercancel', this._onPointerUp);
        },
        remove: function () {
          window.removeEventListener('pointerdown', this._onPointerDown);
          window.removeEventListener('pointermove', this._onPointerMove);
          window.removeEventListener('pointerup', this._onPointerUp);
          window.removeEventListener('pointercancel', this._onPointerUp);
        },
        onPointerDown: function (evt) {
          // só começar drag se tocar na tela (não em botões UI etc.)
          this.dragging = true;
          this.startX = evt.clientX;
          this.startY = evt.clientY;
          // copiar rotação atual
          this.startRot.copy(this.el.object3D.rotation);
          // impedir comportamento padrão para toques
          evt.preventDefault();
        },
        onPointerMove: function (evt) {
          if (!this.dragging) return;
          const dx = evt.clientX - this.startX;
          const dy = evt.clientY - this.startY;
          const sens = this.data.sensitivity * 0.01;
          // rotacionar em Y (horizontal drag) e em X (vertical drag)
          const newY = this.startRot.y - dx * sens;
          const newX = this.startRot.x + (this.data.invertY ? dy * sens : -dy * sens);
          // limitar rotação X para evitar virar de cabeça para baixo (opcional)
          const maxX = Math.PI/2 - 0.05;
          const minX = -Math.PI/2 + 0.05;
          this.el.object3D.rotation.y = newY;
          this.el.object3D.rotation.x = Math.max(minX, Math.min(maxX, newX));
        },
        onPointerUp: function (evt) {
          this.dragging = false;
        }
      });

      // Quando a cena estiver pronta, adicionamos listeners para mostrar/esconder o modelo
      document.addEventListener('DOMContentLoaded', () => {
        // nada aqui — deixamos os event listeners no prazo (abaixo)
      });
    </script>
  </head>

  <body>
    <div id="hint">Aponte para o target para carregar o modelo. Arraste para rotacionar.</div>

    <a-scene
      vr-mode-ui="enabled: false"
      embedded
      mindar-image="imageTargetSrc: ./targets.mind; autoStart: true;"
      color-space="sRGB"
      renderer="colorManagement: true"
      device-orientation-permission-ui="enabled: false"
    >
      <a-assets>
        <!-- ajuste o src para o nome do seu arquivo .glb -->
        <a-asset-item id="modelo" src="modelo.glb"></a-asset-item>
      </a-assets>

      <!-- câmera MindAR -->
      <a-camera position="0 0 0"></a-camera>

      <!-- anchor/target: o modelo fica como filho aqui para aparecer ao detectar -->
      <a-entity id="anchor" mindar-image-target="targetIndex: 0">
        <!-- Modelo dentro do anchor; começa invisível até targetFound -->
        <a-gltf-model
          id="model"
          src="#modelo"
          visible="false"
          position="0 10 10"
          rotation="0 180 0"
          scale="0.003 0.003 0.003"
          touch-rotate
        ></a-gltf-model>
      </a-entity>

      <script>
        // Controle de visibilidade pelo target (aparece ao detectar, some ao perder)
        (function () {
          const anchor = document.querySelector('#anchor');
          const model = document.querySelector('#model');

          anchor.addEventListener('targetFound', () => {
            // mostra o modelo
            model.setAttribute('visible', 'true');
            // opcional: garantir que o modelo começa numa rotação padrão ao aparecer
            // model.object3D.rotation.set(0, Math.PI, 0);
          });

          anchor.addEventListener('targetLost', () => {
            // se preferir esconder quando perder, habilite:
            model.setAttribute('visible', 'false');

            // se quiser que o modelo continue visível após perder o target,
            // comente a linha acima.
            //
            // model.setAttribute('visible', 'true');
          });
        })();
      </script>
    </a-scene>
  </body>
</html>
